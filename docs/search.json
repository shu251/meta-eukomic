[
  {
    "objectID": "main.html",
    "href": "main.html",
    "title": "Meta-eukomic",
    "section": "",
    "text": "SKH last updated August 2024\nLocation for raw files: /scratch/group/hu-lab/meta-eukomics/raw-data Individual R1 and R2 files are 2.9 and 2.7 G, respectively.\n\n\n\nCohen NR, Alexander H, Krinos AI, Hu SK, Lampe RH. Marine Microeukaryote Metatranscriptomics: Sample Processing and Bioinformatic Workflow Recommendations for Ecological Applications. Frontiers in Marine Science 2022; 9.\nKrinos AI, Cohen NR, Follows MJ, Alexander H. Reverse engineering environmental metatranscriptomes clarifies best practices for eukaryotic assembly. BMC Bioinformatics 2023; 24: 74.\n\n\n\n\nHigh performance computer (HPC) hosted by my University. This is the TAMU HPRC."
  },
  {
    "objectID": "main.html#background-reading",
    "href": "main.html#background-reading",
    "title": "Meta-eukomic",
    "section": "",
    "text": "Cohen NR, Alexander H, Krinos AI, Hu SK, Lampe RH. Marine Microeukaryote Metatranscriptomics: Sample Processing and Bioinformatic Workflow Recommendations for Ecological Applications. Frontiers in Marine Science 2022; 9.\nKrinos AI, Cohen NR, Follows MJ, Alexander H. Reverse engineering environmental metatranscriptomes clarifies best practices for eukaryotic assembly. BMC Bioinformatics 2023; 24: 74."
  },
  {
    "objectID": "main.html#working-environment",
    "href": "main.html#working-environment",
    "title": "Meta-eukomic",
    "section": "",
    "text": "High performance computer (HPC) hosted by my University. This is the TAMU HPRC."
  },
  {
    "objectID": "main.html#determine-assembly-groups",
    "href": "main.html#determine-assembly-groups",
    "title": "Meta-eukomic",
    "section": "2.1 1. Determine assembly groups",
    "text": "2.1 1. Determine assembly groups\nWhen we have more than one sample, it is best to “group” samples for the assembly steps. Often this takes a few attempts and is a balance of an ideal plan vs. how much computational power you may have."
  },
  {
    "objectID": "main.html#trim-qc",
    "href": "main.html#trim-qc",
    "title": "Meta-eukomic",
    "section": "2.2 2. Trim & QC",
    "text": "2.2 2. Trim & QC\nInitial Fastqc\nCode for slurm script run on the HPC to run fastqc (fastqc.slurm). For this set of samples, it took 10 minutes and used 290 MB. CPU used: 00:12:27.\n# module load FastQC/0.11.9-Java-11\n\nfastqc /scratch/group/hu-lab/meta-eukomics/raw-data/HS039_S90_L004_R1_001.fastq.gz\nfastqc /scratch/group/hu-lab/meta-eukomics/raw-data/HS039_S90_L004_R2_001.fastq.gz\nIn order to look at the output .html files, they need to be opened locally.\nscp $HPRC-ADDRESS:/scratch/group/hu-lab/meta-eukomics/raw-data/HS039_S90_L004_R1_001_fastqc.html meta-eukomic/output-files/\nThen we need to trim the individual reads, removing any sequencing-based primers, etc. We can use the program, Trimmomatic for this. R1 reads are forward and R2 are reverse. The Trimmomatic software requires input reads and then output trimmed and unpaired reads (the latter of which are discarded). Another input file required is a list of the possible primers and adapters from sequencing, adapters-primers.fa.\nSlurm script, trim_fastqc.slurm. Below, trim parameter include:\n\nRemove adapters, found in adapters-primers.fa\nRemove leading low quality or N bases (below quality 3) (LEADING:3)\nRemove trailing low quality or N bases (below quality 3) (TRAILING:3)\nScan the read with a 4-base wide sliding window, cutting when the average quality per base drops below 10 (SLIDINGWINDOW:4:10)\nDrop reads shorter than 50 bases long (MINLEN:50)\n\nmodule load Trimmomatic/0.39-Java-11\n\njava -jar $EBROOTTRIMMOMATIC/trimmomatic-0.39.jar PE /scratch/group/hu-lab/meta-eukomics/raw-data/HS039_S90_L004_R1_001.fastq.gz /scratch/group/hu-lab/meta-eukomics/raw-data/HS039_S90_L004_R2_001.fastq.gz  /scratch/group/hu-lab/meta-eukomics/raw-data/HS039_S90_L004_R1_trimmed.fastq.gz /scratch/group/hu-lab/meta-eukomics/raw-data/HS039_S90_L004_R1_unpaired.fastq.gz /scratch/group/hu-lab/meta-eukomics/raw-data/HS039_S90_L004_R2_trimmed.fastq.gz /scratch/group/hu-lab/meta-eukomics/raw-data/HS039_S90_L004_R2_unpaired.fastq.gz ILLUMINACLIP:adapters-primers.fa:2:30:10 LEADING:3 TRAILING:3 SLIDINGWINDOW:4:10 MINLEN:50\n\n# \"$EBROOTTRIMMOMATIC/trimmomatic-0.39.jar\" note that this is specific to the HPRC system we are using\n\necho \"Trimmomtatic complete. Repeating fastqc\"\n\nmodule load FastQC/0.11.9-Java-11\n\nfastqc /scratch/group/hu-lab/meta-eukomics/raw-data/HS039_S90_L004_R1_trimmed.fastq.gz\nfastqc /scratch/group/hu-lab/meta-eukomics/raw-data/HS039_S90_L004_R2_trimmed.fastq.gz\n\nThe above trimming steps took 615 MB of memory and 2 hours."
  },
  {
    "objectID": "main.html#remove-ribosomal-rna",
    "href": "main.html#remove-ribosomal-rna",
    "title": "Meta-eukomic",
    "section": "2.3 3. Remove ribosomal RNA",
    "text": "2.3 3. Remove ribosomal RNA\nSortmerna installation guidelines and usage can be found here.\nOn the TAMU HPRC, this is where we needed to make a conda environment to run this.\n# Load anaconda\nmodule load Anaconda3/2022.05\n\n# modify bioconda config for sortmeRNA\nconda config --add channels defaults\nconda config --add channels bioconda\nconda config --add channels conda-forge\nconda config --set channel_priority strict\nSearch for sortmerna using conda:\nconda search sortmerna\nCreate a conda environment specific for sortmerna, activate it, and install it.\nconda create --name sortmerna_env\nconda activate sortmerna_env\nconda install sortmerna\nAnswer “yes” (Y) to installation questions. Now when you run SortMeRNA, you need to activate this conda environment and execute your code. The next step is to download the databases to use for this program.\n\nSortMeRNA databases\nSeparately, you need to download the databases to “align” and check the sequences for ribosomal RNAs. See sortmerna-db-build.slurm.\nInstructions for downloading version 4:\n# Move to the location you want your rRNA databases stored\ncd /scratch/group/hu-lab/meta-eukomics/ \n\n# Download from github release \nwget https://github.com/biocore/sortmerna/releases/download/v4.3.4/database.tar.gz\n\n# Make new directory for this and un-zip downloaded file\nmkdir rRNA_databases_v4\ntar -xvf database.tar.gz -C rRNA_databases_v4\n\n\nRun SortMeRNA (optional)\nIn your slurm script, activate conda, and then the sortmerna environment (sortmeRNA.slurm):\n# Load anaconda\nmodule load Anaconda3/2022.05\nconda activate sortmerna_env\n\nmkdir /scratch/group/hu-lab/meta-eukomics/rRNA-sort\n\nsortmerna -ref /scratch/group/hu-lab/meta-eukomics/rRNA_databases_v4/smr_v4.3_sensitive_db.fasta \\\n-reads /scratch/group/hu-lab/meta-eukomics/raw-data/HS039_S90_L004_R1_trimmed.fastq.gz \\\n-reads /scratch/group/hu-lab/meta-eukomics/raw-data/HS039_S90_L004_R2_trimmed.fastq.gz \\\n-workdir /scratch/group/hu-lab/meta-eukomics/rRNA-sort/ -aligned rRNA-aligned -other non-rRNA\n-fastx --paired_in --out2 --threads $SLURM_CPUS_PER_TASK\n-paired_in: The option ‘paired_in’ is optimal for users who want all reads in the other.fasta file to be non-rRNA. However, there are small chances that reads which are non-rRNA will also be put into the aligned.fasta file.\nSince the SortmeRNA tool is optimized to take things that are aligned with the rRNA databases and put them in a file called “aligned”, then we need to use the other.fasta output file. The argument for this is -out2\nNecessary flags for retaining the non-rRNA aligned reads and outputting them as separate R1 and R2 files: -other, -fastx, --paired_in, and --out2. To learn more about this check out this thread: How do I properly run sortmerna? https://github.com/sortmerna/sortmerna/issues/333\n\nThis was run with 32 threads and 1 node. It took 2 hours 45 minutes and used just over 16 GB of memory.\n\n\nThe total number of reads that aligned to the rRNA databases was pretty small. I am planning to not use the Sorted reads, as there are some issue with the program. Will look for another way to sort reads."
  },
  {
    "objectID": "main.html#assembly",
    "href": "main.html#assembly",
    "title": "Meta-eukomic",
    "section": "2.4 4. Assembly",
    "text": "2.4 4. Assembly\nThe next step is to take all the trimmed reads and bring them together to make longer, more continuous sequences, called contigs. Here, we will use two assemblers and combine the results. Each one is built slightly differently.\n\nMEGAHIT (assembly 1)\nWe will first use megahit. To save the assemblies separately, make a new assembly output file in your working scratch space. mkdir /scratch/group/hu-lab/meta-eukomics/assembly\nThe megahit command below, outputs contigs in the new assembly directory, only keeps reads longer than 100 bps, and uses the megahit preset for lots of diversity in a sample (meta-large).\nMegahit uses multiple k-mer strategy, and we can set the min and max k. In order to reduce the complexity of the de Bruijin graph, a kmin size of 25 and higher (like 27) is better.\nSee slurm script: megahit-assembly.slurm\nmodule load GCCcore/11.2.0\nmodule load MEGAHIT/1.2.9\n\nmegahit -1 /scratch/group/hu-lab/meta-eukomics/raw-data/HS039_S90_L004_R1_trimmed.fastq.gz -2 /scratch/group/hu-lab/meta-eukomics/raw-data/HS039_S90_L004_R2_trimmed.fastq.gz -o /scratch/group/hu-lab/meta-eukomics/assembly/ --min-contig-len 1000 --presets meta-large --num-cpu-threads 32\n\nWith the above settings, megahit recovered 31,331 contigs, total 44610184 bp, min 1000 bp, max 10674 bp, avg 1423 bp, N50 1391 bp. And this took about 10 hours.\n\n\nOn the HPC, this was run on 1 node, 4 cores per node, and it used 18.5 GBs of memory.\n\nMegahit assembly location: /scratch/group/hu-lab/meta-eukomics/assembly/megahit-output/final.contigs.fa\nOptional: Visualize your megahit assembly\nWhen megahit assembly is complete, use this option to visualize it: https://github.com/voutcn/megahit/wiki/Visualizing-MEGAHIT’s-contig-graph\n\n\nIDBA-Tran (assembly 2)\nIDBA-tran is another de novo assembler. Uses local assembly to reconstruct missing kmers in low-expressed transcripts.\nSee script: idba-assembly.slurm to run assembly with minimum kmer at 20 and max kmer at 50 with a 5 step increment of kmer.\necho \"unzip files\"\ngunzip /scratch/group/hu-lab/meta-eukomics/raw-data/HS039_S90_L004_R*_trimmed.fastq.gz\n\nmodule load GCC/8.2.0-2.31.1 \nmodule load IDBA-UD/1.1.3\n\n# Convert fastq R1 and R2 files into a single 'interleaved` fastq files\nfq2fa --merge --filter /scratch/group/hu-lab/meta-eukomics/raw-data/HS039_S90_L004_R1_trimmed.fastq /scratch/group/hu-lab/meta-eukomics/raw-data/HS039_S90_L004_R2_trimmed.fastq /scratch/group/hu-lab/meta-eukomics/assembly/merged-PE-for-idba.fa\n\n# Run assembly\nidba_tran -r /scratch/group/hu-lab/meta-eukomics/assembly/merged-PE-for-idba.fa -o /scratch/group/hu-lab/meta-eukomics/assembly/idba-out --mink 20 --maxk 50 --step 5 --num_threads 16\n\n# Make sure fastq files are re-zipped:\ngzip /scratch/group/hu-lab/meta-eukomics/raw-data/HS039_S90_L004_R1_trimmed.fastq\ngzip /scratch/group/hu-lab/meta-eukomics/raw-data/HS039_S90_L004_R2_trimmed.fastq\n\nUsing 8 cores, the IDBA-tran assembly took about 23 hours and used 130 GB of memory.\n\nThe IDBA-tran output includes separation by k-mer length. So there are multiple “contig-X.fa” files. Where contig-25.fa is the output contigs at k-mer = 25. The IDBA program determines which one is best and then puts this into the final contig.fa file. Output: /scratch/group/hu-lab/meta-eukomics/assembly/idba-out/contig.fa"
  },
  {
    "objectID": "main.html#evaluate-assemblies",
    "href": "main.html#evaluate-assemblies",
    "title": "Meta-eukomic",
    "section": "2.5 5. Evaluate assemblies",
    "text": "2.5 5. Evaluate assemblies\n\nQUAST\nQUAST stands for QUality ASsessment Tool and it is a tool for evaluating assemblies. Not all tools for evaluating assemblies will work, as most are built for metagenomics or require a reference genome. In this case, we do not have a reference genome.\nFirst for the IDBA output quast-idba.slurm:\nmodule load GCC/9.3.0\nmodule load OpenMPI/4.0.3\nmodule load QUAST/5.0.2-Python-3.8.2\n\nquast.py /scratch/group/hu-lab/meta-eukomics/assembly/idba-out/contig.fa \\\n        -1 /scratch/group/hu-lab/meta-eukomics/raw-data/HS039_S90_L004_R1_trimmed.fastq.gz -2 /scratch/group/hu-lab/meta-eukomics/raw-data/HS039_S90_L004_R2_trimmed.fastq.gz \\\n        -o /scratch/group/hu-lab/meta-eukomics/assembly/idba-out/ \\\n        --threads $SLURM_CPUS_PER_TASK\n\nThis was run on 1 node with 16 cores. It used 3.5 GB of memory in about 1 hour. 6:15 CPUs used.\n\nRepeat for the megahit output quast-megahit.slurm:\nmodule load GCC/9.3.0\nmodule load OpenMPI/4.0.3\nmodule load QUAST/5.0.2-Python-3.8.2\n\nquast.py /scratch/group/hu-lab/meta-eukomics/assembly/megahit-output/final.contigs.fa \\\n        -1 /scratch/group/hu-lab/meta-eukomics/raw-data/HS039_S90_L004_R1_trimmed.fastq.gz -2 /scratch/group/hu-lab/meta-eukomics/raw-data/HS039_S90_L004_R2_trimmed.fastq.gz \\\n        -o /scratch/group/hu-lab/meta-eukomics/assembly/megahit-output/ \\\n        --threads $SLURM_CPUS_PER_TASK\n\nAt 16 cores (1 node), this took about 1 hour at 3 GB of memory.\n\n\nInterpret QUAST\nDownload files locally from:\n\nPDF files: meta-eukomics/assembly/*-out/basic_stats/*.pdf\nUse an ICARUS html viewer: meta-eukomics/assembly/*-out/icarus*\nBasic read stats: meta-eukomics/assembly/*-out/reads_stats/reads_report.tsv\n\n\nExample output from QUAST\nidba output\nAssembly                    contig   \n# contigs (&gt;= 0 bp)         892652   \n# contigs (&gt;= 1000 bp)      13948    \n# contigs (&gt;= 5000 bp)      16       \n# contigs (&gt;= 10000 bp)     0        \n# contigs (&gt;= 25000 bp)     0        \n# contigs (&gt;= 50000 bp)     0        \nTotal length (&gt;= 0 bp)      310591507\nTotal length (&gt;= 1000 bp)   19165345 \nTotal length (&gt;= 5000 bp)   101378   \nTotal length (&gt;= 10000 bp)  0        \nTotal length (&gt;= 25000 bp)  0        \nTotal length (&gt;= 50000 bp)  0        \n# contigs                   105801   \nLargest contig              9483     \nTotal length                78684450 \nGC (%)                      53.19    \nN50                         714      \nN75                         581      \nL50                         38334    \nL75                         69112    \n# total reads               110011298\n# left                      54322593 \n# right                     54322593 \nMapped (%)                  28.29    \nProperly paired (%)         19.43    \nAvg. coverage depth         27       \nCoverage &gt;= 1x (%)          99.98    \n# N's per 100 kbp           0.00     \nmegahit output\nAssembly                    final.contigs\n# contigs (&gt;= 0 bp)         31331        \n# contigs (&gt;= 1000 bp)      31331        \n# contigs (&gt;= 5000 bp)      27           \n# contigs (&gt;= 10000 bp)     2            \n# contigs (&gt;= 25000 bp)     0            \n# contigs (&gt;= 50000 bp)     0            \nTotal length (&gt;= 0 bp)      44610184     \nTotal length (&gt;= 1000 bp)   44610184     \nTotal length (&gt;= 5000 bp)   176055       \nTotal length (&gt;= 10000 bp)  21295        \nTotal length (&gt;= 25000 bp)  0            \nTotal length (&gt;= 50000 bp)  0            \n# contigs                   31331        \nLargest contig              10674        \nTotal length                44610184     \nGC (%)                      53.78        \nN50                         1391         \nN75                         1152         \nL50                         12043        \nL75                         20904        \n# total reads               108929544    \n# left                      54322593     \n# right                     54322593     \nMapped (%)                  24.47        \nProperly paired (%)         18.5         \nAvg. coverage depth         47           \nCoverage &gt;= 1x (%)          99.98        \n# N's per 100 kbp           0.00         \nNotes on comparison:\nIDBA output a lot more contigs, but they are shorter. Megahit has many fewer (31,331 / 105,801) of the total contigs. However, contigs over 1000 bps from IDBA drops to only 13K. Demonstrating that most of them are between 500 - 1000 bps (because the program only reports contigs greater than 500 bps). Megahit, on the otherhand, has over 31k contigs that are greater than 1000 bps in length. For super long contigs, we get 27 from megahit and only 16 from idba (&gt;5K bps).\nAs a result, we do get more of the original transcripts mapping to the IDBA output. but the average coverage is 27. Megahit has a few points fewer for % mapped, but the average coverage depth is 47.\nThese assemblies can be combined below."
  },
  {
    "objectID": "main.html#cluster-assembly-output-mmseqs2",
    "href": "main.html#cluster-assembly-output-mmseqs2",
    "title": "Meta-eukomic",
    "section": "2.6 6. Cluster assembly output (mmseqs2)",
    "text": "2.6 6. Cluster assembly output (mmseqs2)\nBecause we have outputs from two separate assemblies, we can use a program to “cluster” the output contigs together. The clustering / merging of contigs is based on sequence similarity, so we need to include a similarity parameter that is kind of arbitrary.\nWe will use mmseqs2 and try this at 99% similarity. MMseq stands for “Many-against-Many sequence searching”\nFirst, the output contig files from IDBA and Megahit are combined: cluster-mmseqs2.slurm\n# Precursor load to use MMseqs2 on HPRC\nmodule load GCC/10.2.0\nmodule load OpenMPI/4.0.5\nmodule load MMseqs2/13-45111\n\nmkdir /scratch/group/hu-lab/meta-eukomics/assembly/combined-assembly\n\ncat /scratch/group/hu-lab/meta-eukomics/assembly/megahit-output/final.contigs.fa /scratch/group/hu-lab/meta-eukomics/assembly/idba-out/contig.fa &gt; /scratch/group/hu-lab/meta-eukomics/assembly/combined-assembly/combined-assemblies.fasta\n\n\n# Use the 'easy-linclust' option\n\nmmseqs easy-linclust /scratch/group/hu-lab/meta-eukomics/assembly/combined-assembly/combined-assemblies.fasta /scratch/group/hu-lab/meta-eukomics/assembly/combined-assembly/clusterRes /scratch/group/hu-lab/meta-eukomics/assembly/combined-assembly/tmp --threads=$SLURM_CPUS_PER_TASK\n\nIf you’re working with a massive amount of data, this is a good place to try reducing the percent identity with mmseqs down to 99% or 98%.\n\n32 cores (1 node), this took just under 1 hour and 1.3 GB of memory.\n\n\n6.1 QUAST new combined assembly\nRepeat assembly evaluation with quast (quast-combined.slurm)\nquast.py /scratch/group/hu-lab/meta-eukomics/assembly/combined-assembly/combined-assemblies.fasta \\\n        -1 /scratch/group/hu-lab/meta-eukomics/raw-data/HS039_S90_L004_R1_trimmed.fastq.gz -2 /scratch/group/hu-lab/meta-eukomics/raw-data/HS039_S90_L004_R2_trimmed.fastq.gz \\\n        -o /scratch/group/hu-lab/meta-eukomics/assembly/combined-assembly/ \\\n        --threads $SLURM_CPUS_PER_TASK\nNow, with a combined assembly we get a better deal with our contigs. We have more like 137,132 contigs. This is more than both IDBA and megahit, but we are now getting more than 45K greater than 1000 bp, and 43 greater than 5K bps. And now, the percent mapped from original reads is higher at 31%, but our average coverage depth drops to 21. This is fine because we can map more reads to our assemblies."
  },
  {
    "objectID": "main.html#transdecoder",
    "href": "main.html#transdecoder",
    "title": "Meta-eukomic",
    "section": "2.7 7. Transdecoder",
    "text": "2.7 7. Transdecoder\nFrom the combined assemblies, we need to extract the long open reading frames (ORFs). ORFs will be identified that have at least 100 aminos acids. Then we also follow this with predicting the likely coding regions so we can continue with protein annotation.\ntransdecoder.slurm:\nmodule load GCC/11.3.0\nmodule load TransDecoder/5.5.0\n\n#extract the long open reading frames\nTransDecoder.LongOrfs -t /scratch/group/hu-lab/meta-eukomics/assembly/combined-assembly/combined-assemblies.fasta --output_dir /scratch/group/hu-lab/meta-eukomics/predictions/\n\n# predict the likely coding regions\nTransDecoder.Predict -t /scratch/group/hu-lab/meta-eukomics/assembly/combined-assembly/combined-assemblies.fasta --output_dir /scratch/group/hu-lab/meta-eukomics/predictions/\nOutput files: /scratch/group/hu-lab/meta-eukomics/assembly/combined-assembly/combined-assemblies.fasta.transdecoder.*\n\nAt 16 cores (1 node), job took 5.5 GB of memory and 1 hour.\n\n\n7.1 (optional) MMSeq2 part II\nAt this point, if you have a LOT of samples and large amounts of data, a repeat clustering of the proteins will help reduce the amount of data you’re working with."
  },
  {
    "objectID": "main.html#key-output-files",
    "href": "main.html#key-output-files",
    "title": "Meta-eukomic",
    "section": "2.8 8. Key output files",
    "text": "2.8 8. Key output files\nAt this point, you have assembled, quality checked, and predicted proteins for all your metatranscriptomes.\n\nAssembled contigs: /scratch/group/hu-lab/meta-eukomics/assembly/combined-assembly/clusterRes_rep_seq.fasta\nPredicted proteins: /scratch/group/hu-lab/meta-eukomics/predictions see files ending in .gff3 and .pep\n/scratch/group/hu-lab/meta-eukomics/assembly/combined-assembly/combined-assemblies.fasta.transdecoder.*\n\nNext steps: annotate above files, based on predicted proteins or the contigs and determine transcript abundance by mapping the original trimmed fastq reads back onto these contigs."
  },
  {
    "objectID": "main.html#annotation",
    "href": "main.html#annotation",
    "title": "Meta-eukomic",
    "section": "2.9 9. Annotation",
    "text": "2.9 9. Annotation\nThe goal of the below steps is to match assembled reads with taxonomy and protein databases.\n\n9.1 Marferret & Diamond\nFor taxonomic annotation, using MarFERReT\nFor this we will use Diamond. This is a really fast tool for querying nucleotide or protein sequences again a database. You need to first make a diamond database (.dmnd), and then use blastp or something to\nTo use the Marferrt resource, we need to query our combined assembly and predicted protein IDs with the Marferret this with diamond.\nIn order to run Diamond (or any similar blast-like program), we need to consider a few variables & terms.\n\ne-value (expectation value): This is the number of hits that could be found by chance. So an e-value of 50, means up to 50 of the matches (or hits) in your results could be a result of chance. Therefore, lower e-values mean you will get better matches, or matches of better quality. Generally, these programs may have e-value defaults of 10, which may be helpful for looking at all possible results. But an e-value of 0.01 would be better to use to look for good matches. There is a formula for how we calcuate e-values, and it depends on the size of the query sequences and the databases.\nBit score: This is the result of a log2 scaled and normalized score of the number of matches that could be found by chance based on the database size.\n\nDiamond default e-value is 0.001, I am changing mine to 0.0001. And I’m using the --sensitive setting which finds significant matches with &gt;50 bits for fragments that are between 30-40 aa.\nmodule load GCC/11.2.0\nmodule load DIAMOND/2.0.15\n\ndiamond blastp --threads $SLURM_CPUS_PER_TASK --query /scratch/group/hu-lab/meta-eukomics/assembly/combined-assembly/combined-assemblies.fasta.transdecoder.pep --db /scratch/group/hu-lab/marferret/data/MarFERReT.v1.1.1.dmnd -o /scratch/group/hu-lab/meta-eukomics/annotation/meta-eukomic_marferret_07082024.txt --sensitive --evalue 0.0001 --max-target-seqs 10 --outfmt 6 qseqid sseqid sallseqid evalue bitscore qlen slen\n\nWith 32 cores (1 node), this took 20 minutes and 10 GB of memory."
  },
  {
    "objectID": "main.html#transcript-counts",
    "href": "main.html#transcript-counts",
    "title": "Meta-eukomic",
    "section": "2.10 10. Transcript counts",
    "text": "2.10 10. Transcript counts\nFor determining “gene expression”, we estimate this from the number of transcripts (sequenced reads) that map onto your assembled reads. We will use salmon.\nFirst we need to index your transcripts - salmon uses a quasi-map approach to quantify the reads.\nmodule load GCC/11.2.0\nmodule load OpenMPI/4.1.1\nmodule load Salmon/1.7.0\n\nmkdir /scratch/group/hu-lab/meta-eukomics/salmon-quant\n\nsalmon index -t /scratch/group/hu-lab/meta-eukomics/assembly/combined-assembly/clusterRes_rep_seq.fasta -i /scratch/group/hu-lab/meta-eukomics/salmon-quant/ -p $SLURM_CPUS_PER_TASK\n\nIndexing this data took 45 minutes (32 cores, 1 node) and 1.2 GB of memory\n\nsalmon quant -i /scratch/group/hu-lab/meta-eukomics/salmon-quant/ -l A \\\n         -1 /scratch/group/hu-lab/meta-eukomics/raw-data/HS039_S90_L004_R1_trimmed.fastq.gz \\\n         -2 /scratch/group/hu-lab/meta-eukomics/raw-data/HS039_S90_L004_R2_trimmed.fastq.gz \\\n         -p $SLURM_CPUS_PER_TASK --validateMappings -o /scratch/group/hu-lab/meta-eukomics/salmon-quant/quant\n\nAt 32 cores (1 node), transcript counts took 3.5 hours and 4.2 GB of memory.\n\nRead more here, especially on how to loop through samples: https://combine-lab.github.io/salmon/getting_started/#indexing-txome"
  },
  {
    "objectID": "main.html#compile-outputs",
    "href": "main.html#compile-outputs",
    "title": "Meta-eukomic",
    "section": "2.11 11. Compile outputs",
    "text": "2.11 11. Compile outputs\n\nAnnotation from marferret: /scratch/group/hu-lab/meta-eukomics/annotation/meta-eukomic_marferret_07082024.txt Column 1 is the contig ID name (qseqid) and the second ID is the match ID from the database (sseqid). These two columns need to be put into a new dataframe and called “TRANSCRIPTID” and “GENEID”\nFor the GENEIDs, the “mftXXXXXXXXX” names correspond to pfam IDs in: /scratch/group/hu-lab/marferret/data/MarFERReT.v1.1.1.best_pfam_annotations.csv.gz\n\n** Use MarFERReT.v1.1.1.taxonomies.tab.gz to get the tax id and then line this up with MarFERReT.v1.1.1.metadata.csv to get the actual taxonomy.\nSee scripts/compile-metat-results.R. This script will output an R object called tx_gene_KEY.\n\n11.1 Transcipt counts\nFor obtaining transcript-level estimates from the salmon count files, we need to use the R library tximport. Review the manual here.\nSalmon output should be /meta-eukomics/salmon-quant/quant/quant.sf\nFrom the compile-metat-results.R code, you can import this tx_gene_KEY object to use in the tximport estimation of TPMs. First, you need to run the command tximport.\nThis should output a txi object called txi_metat and then you can create a paired sample table.\nSee the Rscript scripts/tximport_run.R\n## Example:\n# library(tximport)\n# txi &lt;- tximport::tximport(files, type = \"salmon\", tx2gene = tx2gene_in)\n\n\n11.2 Get TPMs & Annotation information\nSee scripts/format-output-tables.R. This takes the txi objects and uses the command makeCountsFromAbundance() to generate a TPM file that represents the transcript-length corrected estimates.\nThen the script imports the annotation file, merges it with the count information to create a large R object with TPMs and annotation information.\n\n\n11.3 Reformat for hackathon!\nload(\"/scratch/group/hu-lab/meta-eukomics/counts_metat_df_annot.RData\", verbose = TRUE)\nglimpse(counts_metat_df_annot)"
  },
  {
    "objectID": "main.html#metatranscriptome-run-information",
    "href": "main.html#metatranscriptome-run-information",
    "title": "Meta-eukomic",
    "section": "2.12 Metatranscriptome run information",
    "text": "2.12 Metatranscriptome run information\n\n\n\nSoftware\nVersion\n\n\n\n\nFastqc\n0.11.9\n\n\nTrimmomatic\n0.39\n\n\nSortMeRNA\n4.3.7\n\n\nmegahit\n1.2.9\n\n\nIDBA-Tran\n1.1.3\n\n\nquast\n5.0.2\n\n\nmmseqs2\n13-45111\n\n\nTransDecoder\n5.5.0\n\n\nSalmon\n1.7.0\n\n\nDiamond\n2.0.15\n\n\n\n\n\n\n\n\nCitations\n\n[fastqc]\n[trimmomatic]\nSortMeRNA: Kopylova E., Noe L. and Touzet H., “SortMeRNA: Fast and accurate filtering of ribosomal RNAs in metatranscriptomic data”, Bioinformatics (2012), doi: 10.1093/bioinformatics/bts611.\n[megahit]\nIDBA-Tran\nSalmon: Patro, R., Duggal, G., Love, M. I., Irizarry, R. A., & Kingsford, C. (2017). Salmon provides fast and bias-aware quantification of transcript expression. Nature Methods.\nQUAST: Gurevich A, Saveliev V, Vyahhi N, Tesler G. QUAST: quality assessment tool for genome assemblies. Bioinformatics. 2013;29: 1072 1075. doi:10.1093/bioinformatics/btt086 , https://www.ncbi.nlm.nih.gov/pubmed/23422339"
  }
]